import ContStateList

-- Accumulating Adjectives
-- ------------------------------------------------
different, longer :: ETET r
different = ContT $ \k -> do {s <- get; k (\p x -> p x && x `notElem` s)}

longer = ContT $ \k -> do
  s <- get
  k (\p x ->  p x && (null s || x > maximum s))
-- ------------------------------------------------

-- CONNECTIVES
-- ===========

class Fusable a where
  fuse :: a -> a -> a
instance Fusable Bool where
  fuse = (&&)
instance Fusable Ent where
  fuse = oplus

conj :: (Monad m, Fusable r) => m r -> m r -> m r
conj = liftM2 fuse


-- DETERMINERS
-- ===========

-- Auxiliary functions for working with restrictors
-- ------------------------------------------------
check :: ET Bool -> Ent -> Dstate Bool
check p = lower . rap p . unit

-- "bottle" takes a ref x and a stateful bool t, and replaces the (True, s')
-- pairs in t with (x, s') pairs, and discards the rest;
-- intuitively, it filters t, and then "bottles" x up with the various
-- result states:
--   bottle 3 (\s -> [(T,7:s), (F,8:s), (T,9:s)]) == \s -> [(3,7:s), (3,9:s)]
bottle :: Ent -> Dstate Bool -> Dstate Ent
bottle x t = mfilter id t >> return x

-- if x completely fails p, "bottle" returns the empty individual:
--   (\s -> [])
-- we can try and flush this out, but it might blow up in our faces if p
-- contains a pronoun; better just to leave the empty individual, which 
-- eventually dissipates in the concatenation of `someD' anyway
charact ::  ET Bool -> [Dstate Ent]
charact p = map (bottle <*> check p) domAtoms
            -- equivalent to:
            -- map ((>>) <$> mfilter id . check p <*> return) domAtoms
-- ------------------------------------------------

-- Universals
-- ------------------------------------------------
everyD :: Fusable r => ET Bool -> E r
everyD p = ContT $ \k -> do
  let xs = filter (not . null . run) $
           -- flushes out individuals that completely fail the restrictor, 
           -- but explodes if the restrictor contains pronouns :(
           charact p
  let ps = filter (not . null . run) $
           -- the line above protects the computation against scope failure, 
           -- as in "Every short boy likes someone he pities", which will
           -- otherwise fail on Boy1 who doesn't pity anyone. Comment this
           -- line out off to get a more presupposition-failure like semantics
           map (k =<<) xs
  foldl1 conj ps

-- a towerish version of everyD
-- shows slightly different behavior when "different" is in a restrictor
alteveryD :: ET Bool -> E Bool
alteveryD p = ContT $ \k -> StateT $ \s ->
  let witnesses x = filter fst $ runStateT (check p x) s in
  let ps = filter (not . null . (`runStateT` s)) $
           map (\x -> StateT $ \s' -> concat $ [runStateT (k x) (s'++(s'' `minus` s))
                                                 | (_,s'') <- witnesses x]) domAtoms in
  runStateT (foldl1 conj ps) s

-- externally static version of everyD
everyS' :: ET Bool -> E Bool
everyS' = mapContT (\m -> do {s <- get; mapStateT (\ts -> [(any fst ts, s)]) m}) . everyD
-- equivalent to:
-- everyS' p = ContT $ \k -> StateT $ \s -> [(or $ evalStateT (runContT (everyD p) k) s, s)]


-- ==========================
-- ** FUNCTIONAL WITNESSES **
-- ==========================

-- Machinery for making functional witnesses 
skipdist :: [Int] -> Int
skipdist s =
  let dl = [(s!!n) - (s!!(n-1)) | n <- [1..length s - 1]] in
  -- assert ((length . nub) dl == 1) (head dl)
  head dl

findAnchors :: [(Bool,Stack)] -> [Int]
findAnchors alts = map fst $ foldl1 intersect enumStacks
  where enumStacks = [(zip [0..] . snd) alt | alt <- alts]

compress :: [(Bool,Stack)] -> Stack
compress alts = map snd $ foldl1 intersect enumStacks
  where enumStacks = [(zip [0..] . snd) alt | alt <- alts]

makeFunc :: [Int] -> Stack -> Ent
makeFunc anchs hist = Func $ M.fromList splits
  where splits = map (\(i:is) -> (i,is)) $ chunksOf (skipdist anchs) hist'
        hist'  = drop (head anchs) hist

functionalize :: Dstate Bool -> Dstate Bool
functionalize m = StateT $ \s ->
  let alts  = runStateT m s in
  let anchs = findAnchors alts in
  map (\(b,hist) -> (b, [makeFunc anchs hist])) alts

-- Functionalizing universal
--everyF :: ET -> E
everyF :: ET Bool -> E Bool
everyF = mapContT functionalize . everyD


{-
-- generalizes "findAnchors" to patterns generated by multiple universals
-- (probably unnecessary if universals automatically functionalize as soon as
-- they take scope)
findAnchs :: Stack -> [Stack]
findAnchs indices = (maximumBy (comparing length) parts)
  where divisors x = [y | y <- [2..(x `div` 2)], x `mod` y ==0] ++ [x]
        chunks     = [chunksOf n indices | n <- divisors (length indices)]
        parts      = filter ((== 1) . length . nub . map diffs) chunks
-}
